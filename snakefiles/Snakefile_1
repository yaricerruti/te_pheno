#################
## ALL PREDICTORS
#################

##v1

###
## computing all predictors: sequence age, phyloP, DRS, gkmSVM score
## computing chromatin accessibility (1 of 3 outcomes)

######################
## PIPELINE PARAMETERS
######################

#####################
## frequent pathnames
localdata="/mnt/filippo/prj/te_enhancer_conservation/local/data/"
localscript="/mnt/filippo/prj/te_enhancer_conservation/local/src/"

#####################
## regulatory regions
## FUNC = ["ALL", "dELS", "pELS", "PLS", "CTCF-only", "DNase-H3K4me3"]
FUNC = "ALL"

#######################################
## n of randomizations (all predictors)
nrands=0



#####################
## PIPELINE LAUNCHERS
#####################

## full pipeline
rule all:
	input: "main/predictors_matrix.tsv"

## chromatin accessibility
rule all_chromatin_accessibility:
	input: "main/te_base_ovl_ratio.tsv"

## sequence age
rule all_sequence_age:
	input: "main/te_family_age.tsv"

## phyloP
rule all_phyloP:
	input: phyloP=expand("main/phyloP_{func}_average_final.tsv", func=FUNC)


## DRS
rule all_DRS:
	input: DRS=expand("main/DRS_{func}_median_final.tsv", func=FUNC)


## gkmSVM
rule all_gkmSVM:
	input: "main/ccre_SVMmodel_all.tsv"


#######
#######
## MAIN
#######
#######




## =======================================================================================================================================================================================================


#####################
## DATA PREPROCESSING
#####################


#############################
## regulatory data extraction

###
# bed files related to functional regions (ENCODE cCREs) are read and reduced
# a standard bed file is produced

rule cCRE:
	input: localdata+"encodeCcreCombined.bb"
	output: "preprocessing/encodeCcreCombined.bed"
	shell: "bigBedToBed {input} {output}"



########################################################
## selection of cCRE encodeLabels


rule functional_regions_cCRE: ## ~ 700Mb for -c6 dELS, * 6 (cCRE+HMM) = ~ 4.2Gb, resources not necessary
	input: "preprocessing/encodeCcreCombined.bed"
	output: "preprocessing/encodeCcreCombined_{func}.bed"
	params:
		classification = "encodeLabel", ## encodeLabel categ in cCRE bed
		classes = "{func}"
	shell: "Rscript "+localscript+"functional_regions_cCRE.R {input} {output} {params.classification} {params.classes}"


##################################################################
## TE w/ regulatory regions preprocessing, overlap, postprocessing

###
## repeatmasker preprocessing:
## only TEs (repClass %in% LINE, SINE, LTR, DNA) on autosomes are retained 
## standard bed file in output

rule repeatmasker_preprocessing:
	input: localdata+"rmsk_hg38.txt"
	output: "preprocessing/rmsk_preprocessed.bed"
	shell: "Rscript "+localscript+"repeatmasker_prep_TEonly_repNameonly.R {input} {output}"


###
## repeatmasker filtering by length:
## either all or copies longer than the repName median are retained (latter for sensitivity analysis)

rule length_threshold:
	input: "preprocessing/rmsk_preprocessed.bed"
	output: protected("preprocessing/rmsk_filtered.bed")
	params: threshold="median" ## "none" to retain all TEs, "median" to retain copies above family median length
	log: "logs/length_threshold/lost.log"
	shell: "Rscript "+localscript+"repeatmasker_filtering.R {input} {output} {params.threshold} {log}"


###
## merging overlapping TEs, removing TEs overlapping MHC on chr6, randomizing if required, finding overlaps with cCREs

rule ALL_preprocessing:
	input:
		rmsk="preprocessing/rmsk_filtered.bed",
		mhc=localdata+"MHC_GRCh38.p14.bed"
	output: "preprocessing/overlap_output/ALL_{group}_te_func_ovl.bed"
	shell: "Rscript "+localscript+"te_all_preprocessing.R {input.rmsk} {input.mhc} {output} {wildcards.group}"


rule overlap_cCRE:
	input:
		func="preprocessing/encodeCcreCombined_{func}.bed",
		rmsk="preprocessing/rmsk_filtered.bed",
		mhc=localdata+"MHC_GRCh38.p14.bed"
	output: "preprocessing/overlap_output/{func}_{group}_te_func_ovl.bed"
	wildcard_constraints: func="dELS|pELS|PLS|CTCF-only|DNase-H3K4me3"
	resources: mem_mb=6000
	shell: "Rscript "+localscript+"te_func_overlap.R {input.func} {input.rmsk} {input.mhc} {output} {wildcards.group}"

## ========================================================================================================================================================================================================


##########################
## CHROMATIN ACCESSIBILITY
##########################


## ========================================================================================================================================================================================================

###
## overlapping TEs with regulatory elements, computing the number of overlapping bases

rule compute_overlap:
	input:
		rmsk="preprocessing/rmsk_filtered.bed",
		ccre="preprocessing/encodeCcreCombined.bed"
	output: "chrom_acc/rmsk_ccre_overlap.bed"
	shell:
		"""
		cut -f 1-3 {input.ccre} | \
		gawk -v OFS="\\t" ' {{ gsub(/chr/, "", $1) }} 1 ' | \
		intersectBed -a {input.rmsk} -b - -wao | \
		cut -f 1-4,8 > {output}
		"""

###
## computing the fraction of cCRE-overlapping bases for each TE family 

rule compute_ratio:
	input: 
		bed="chrom_acc/rmsk_ccre_overlap.bed",
		rmsk_prep="preprocessing/rmsk_filtered.bed"	
	output: protected("main/te_base_ovl_ratio.tsv")
	shell: "Rscript "+localscript+"te_base_ovl_ratio_all_ccre_light.R {input.rmsk_prep} {input.bed} {output}"


## ========================================================================================================================================================================================================


###############
## SEQUENCE AGE
###############


## ========================================================================================================================================================================================================

#################################################################################
## PREPROCESSING:
## removing sexual and mito chromosomes, producing a bed with the following form:
## chr	start	end	max_age
## chr1	100	200	6

rule preprocess_genomic_age:
	input: localdata+"human_genomic_age.bed"
	output:	"age/human_genomic_age_hg19.bed"
	shell:
		"""
		gawk -v OFS="\\t" ' {{ if($1 != "M" && $1 != "X" && $1 != "Y") print "chr"$1, $2, $3, $5 }} ' {input} > {output}
		"""

##########################################################
## transforming hg19 genomic age bed to hg38 with liftOver

rule liftOver:
	input:
		in_bed="age/human_genomic_age_hg19.bed",
		chain=localdata+"hg19ToHg38.over.chain"
	output: 
		out_bed="age/human_genomic_age_hg38.bed",
		unmapped="age/human_genomic_age_hg38_unmapped.bed"
	shell:
		"""
		liftOver {input.in_bed} {input.chain} {output.out_bed} {output.unmapped} -bedPlus=3 
		"""

##################################################################
## intersecting repeatmasker (already 0-based) and genomic age bed
## the resulting bed will be in the form:
## chr	start	end	te_class	fragment_age	overlap_length
## chr1    752075  752202  AluJb   2     `  3
## chr1    752075  752202  AluJb   3       1
## chr1    752075  752202  AluJb   2       27
## chr1    752075  752202  AluJb   5       3
## chr1    752075  752202  AluJb   2       93

rule intersect_age_bed:
	input:
		rmsk="preprocessing/rmsk_filtered.bed",
		age_bed="age/human_genomic_age_hg38.bed"
	output: "age/rmsk_age_raw.bed"
	shell:
		"""
		gawk -v OFS="\\t" ' {{ print "chr"$1, $2, $3, $4 }} ' {input.rmsk} | \
		intersectBed -wo -a - -b {input.age_bed} | \
		cut -f 1-4,8- > {output}
		"""

######################################################################################################
## since most ranges are duplicated, selecting only TE fragments with longest overlap with genomic age
## see rmsk_age_dict.py for more info on fragment selection
## the resulting bed will be in the form:
## chr1    752075  752202  AluJb   2
## chr1    2264570 2264701 AluJb   6
## chr1    5507965 5508270 AluJb   7 

rule select_age:
	input: "age/rmsk_age_raw.bed"
	output: "age/rmsk_age_processed.bed"
	script: localscript+"rmsk_age_dict.py"

#########################################################################################
## computing family-wise age as median or 90th percentile of family-wise age distribution

rule family_age:
	input: "age/rmsk_age_processed.bed"
	output: protected("main/te_family_age.tsv")
	shell: "Rscript "+localscript+"TE_family_age.R {input} {output}"



##
## =======================================================================================================================================================================================================


#########
## PHYLOP
#########


## =======================================================================================================================================================================================================

################################
## data preprocessing for phyloP

rule bedSplit:
	input: "preprocessing/overlap_output/{funcgroup}_te_func_ovl.bed"
	output:
		ranges="preprocessing/overlap_output/{funcgroup}_te_func_ovl_ranges.bed",
		tags="preprocessing/overlap_output/{funcgroup}_te_func_ovl_tags.bed"
	shell:
		"""
		gawk -F "\\t" -v OFS="\\t" ' {{ print "chr"$1, $2, $3, "ID"NR, $4 }} ' {input} | \
		tee >(cut -f 1-4 > {output.ranges}) | \
		cut -f 4,5 > {output.tags}
		"""

####################
## phyloP extraction

rule intersect_phyloP:
	input:
		bigWig=localdata+"cactus241way.phyloP.bw",
		ranges="preprocessing/overlap_output/{funcgroup}_te_func_ovl_ranges.bed"
	output: "phyloP/{funcgroup}_ID_phyloP.tab"
	resources: mem_mb=4000
	threads: 4
	shell:
		"""
		bigWigAverageOverBed {input.bigWig} {input.ranges} {output} -stats=phyloP/{wildcards.funcgroup}_stats.ra
		"""

################################################################
## phyloP data postprocessing and TE-repName average calculation

rule mergeR:
	input:
		phyloP="phyloP/{funcgroup}_ID_phyloP.tab",
		tags="preprocessing/overlap_output/{funcgroup}_te_func_ovl_tags.bed"
	output: "phyloP/{funcgroup}_ID_phyloP_merged.tsv"
	resources: mem_mb=2000
	shell: "Rscript "+localscript+"merger_predictors_phyloP.R {input.phyloP} {input.tags} {output} {wildcards.funcgroup}"


rule cat_phyloP:
	input: expand("phyloP/{{func}}_{group}_ID_phyloP_merged.tsv", group=["real"]+["rand"+str(x) for x in range(1,nrands+1)])
	output: "phyloP/phyloP_{func}_concatenated.tsv"
	shell: "cat {input} > {output}"

rule compute_phyloP_class_average:
	input: "phyloP/phyloP_{func}_concatenated.tsv"
	output: protected("main/phyloP_{func}_average_final.tsv")
	resources: mem_mb=2000
	shell: "Rscript "+localscript+"phyloP_average.R {input} {output}"

## =======================================================================================================================================================================================================


######
## DRS
######


## =======================================================================================================================================================================================================

#######################################################
## computing weigthed Depletion Rank Score for each TE:

###
## since DRS windows are shifted by 50bps each, each TE will overlap multiple windows, with different DRS.
## the TE-DRS will be computed as the average of DRS weighted for the overlap length between each TE copy  and DRS.

###
## intersecting TEs with DRS windows bed

rule intersect_DRS:
	input:
		tes="preprocessing/overlap_output/{funcgroup}_te_func_ovl.bed",
		DRS=localdata+"DR_score_Stefansson_Nature_2022.bed"
	output: temp("DRS/{funcgroup}_te_func_ovl_DRS.bed")
	resources:
		DRS_instances=1,
		mem_mb=24000
	shell:
		"""
		intersectBed -a {input.tes} -b {input.DRS} -wao | \
		cut -f 1-4,8- | \
		gawk -v OFS="\\t" ' {{ if($6 > 0) print $0 }} ' > {output}
		"""

###
## python dictionary assigns the DRS weighted average to each TE
 
rule weighted_DRS:
	input: "DRS/{funcgroup}_te_func_ovl_DRS.bed"
	output: "DRS/{funcgroup}_te_func_ovl_weighted_DRS.bed"
	resources:
		DRS_instances=1,
		mem_mb=24000
	script: localscript+"weighted_DRS.py"

###
## TE family-DRS is computed as the family median

rule DRS_median:
	input: expand("DRS/{{func}}_{group}_te_func_ovl_weighted_DRS.bed", group=["real"]+["rand"+str(x) for x in range(1,nrands+1)])
	output: protected("main/DRS_{func}_median_final.tsv")
	resources: mem_mb=4000
	shell: "Rscript "+localscript+"DRS_predictors_median.R {output} {input}"

## ========================================================================================================================================================================================================


#########
## GKMSVM
#########


## ========================================================================================================================================================================================================

### gkmSVM trained on 15k cCREs, weights computed for 816 perfectly matching consensus + averaged on single instances for nonmatching classes

###
## subsetting only regions that do not overlap TEs (positive set) and sampling 15k random cCREs for model training

## !!! NOT NECESSARY IF PRETRAINED MODEL IS USED !!!
rule cCRE_train_set:
	input:
		ccre="preprocessing/encodeCcreCombined.bed",
		rmsk=localdata+"rmsk_hg38.txt"
	output: train_set="gkmSVM/ccre_train_set.bed"
	shell:
		"""
		intersectBed -a <(cut -f 1-3 {input.ccre}) -b <(cut -f 6-8 {input.rmsk}) -v | \
		shuf -n 15000 | \
		sort -k1,1 -k2,2n > {output.train_set}
		"""

###
## preprocessing consensus sequences: 816 Dfam consensus sequence names PERFECTLY match repeatmasker repNames (out of 1052 repeatmasker repNames)

rule extracting_consensus:
	input:
		dfam=localdata+"Dfam-RepeatMasker.lib",
		ratio="main/te_base_ovl_ratio.tsv"
	output: 
		matching="gkmSVM/consensus.fa",
		missing="gkmSVM/missing.txt"
	shell: "Rscript "+localscript+"Dfam_preprocessing.R {input.dfam} {input.ratio} {output.matching} {output.missing}"


###
## extracting fasta sequences for all instances belonging to TE families whose name does not perfectly match repeatmasker names

rule extracting_fasta:
	input:
		missing="gkmSVM/missing.txt",
		rmsk=localdata+"rmsk_hg38.txt"
	output: "gkmSVM/missing.fa"
	shell: "Rscript "+localscript+"gkmSVM_extract_fasta.R {input.missing} {input.rmsk} {output}"



###
## training model on 15000 random functional regions that do not overlap TEs,
## training with 5-fold CV
## testing on TE consensus sequences

## !!! NOT NECESSARY IF PRETRAINED MODEL IS USED !!!

rule gkmSVM_consensus:
	input:
		input_bed_train="gkmSVM/ccre_train_set.bed",
		input_consensus="gkmSVM/consensus.fa"
	output:
		output_fasta_train="gkmSVM/ccre_train_set.fa",
		output_neg_bed_train="gkmSVM/neg1x_ccre_train_set.bed",
		output_neg_fasta_train="gkmSVM/neg1x_ccre_train_set.fa",
		output_kernel="gkmSVM/ccre_train_set_kernel.out",
		output_CVpredfn="gkmSVM/ccre_SVMmodel_cvpred.out",
		output_ROCfn="gkmSVM/ccre_SVMmodel_roc.out",
		output_PDFfn="gkmSVM/ccre_SVMmodel_roc.pdf",
		output_weights="gkmSVM/ccre_consensus_SVMmodel_weights.out"
	params:
		params_svmfnprfx="gkmSVM/ccre_SVMmodel"
	resources: gkmSVM_instances=1
	benchmark: "benchmark/gkmSVM_benchmark.tsv"
	shell: "Rscript "+localscript+"gkmSVM_consensus_snake.R \
		{input.input_bed_train} \
		{input.input_consensus} \
		{output.output_fasta_train} \
		{output.output_neg_bed_train} \
		{output.output_neg_fasta_train} \
		{params.params_svmfnprfx} \
		{output.output_kernel} \
		{output.output_CVpredfn} \
		{output.output_ROCfn} \
		{output.output_PDFfn} \
		{output.output_weights}"


###
## testing model on unique TE instances

rule gkmSVM_instances:
	input:
		input_consensus="gkmSVM/consensus.fa",
		input_instances="gkmSVM/missing.fa"
	output:
		output_weights_instances="gkmSVM/ccre_instances_SVMmodel_weights.out"
	params:
		params_svmfnprfx="gkmSVM/ccre_SVMmodel"
	resources: gkmSVM_instances=1
	benchmark: "gkmSVM/benchmark/gkmSVM_benchmark.tsv"
	shell: "Rscript "+localscript+"gkmSVM_classify_pretrained_model.R \
		{input.input_consensus} \
		{input.input_instances} \
		{params.params_svmfnprfx} \
		{output.output_weights_instances}"


###
## 

rule gkmSVM_average:
	input: expand("gkmSVM/ccre_{w}_SVMmodel_weights.out", w=["consensus", "instances"])
	output: protected("main/ccre_SVMmodel_all.tsv")
	shell: "Rscript "+localscript+"gkmSVM_average.R {input} {output}"

##
## =======================================================================================================================================================================================================


##########
## MERGING
##########


## =======================================================================================================================================================================================================


rule predictors_matrix:
	input:
		chrom_acc="main/te_base_ovl_ratio.tsv",
		phyloP=expand("main/phyloP_{func}_average_final.tsv", func=FUNC),
		DRS=expand("main/DRS_{func}_median_final.tsv", func=FUNC),
		age="main/te_family_age.tsv",
		gkmSVM="main/ccre_SVMmodel_all.tsv",
		clade=localdata+"age_clade_match.tsv",
		rmsk=localdata+"rmsk_hg38.txt"
	output: protected("main/predictors_matrix.tsv")
	shell: "Rscript "+localscript+"predictors_merge_full.R {output} {input.rmsk} {input.clade} {input.chrom_acc} {input.gkmSVM} {input.age} {input.phyloP} {input.DRS}"


